// This file is part of playd.
// playd is licensed under the MIT licence: see LICENSE.txt.

/**
 * @file
 * Declaration of the Player class, and associated types.
 * @see player.cpp
 */

#ifndef PLAYD_PLAYER_HPP
#define PLAYD_PLAYER_HPP

#include <cstdint>
#include <map>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "audio/audio_system.hpp"
#include "audio/audio.hpp"
#include "response.hpp"
#include "cmd_result.hpp"

/**
 * A Player contains a loaded audio file and a command API for manipulating it.
 * @see Audio
 * @see AudioSystem
 */
class Player
{
public:
	/**
	 * Constructs a Player.
	 * @param audio The AudioSystem to be used by the player.
	 */
	Player(AudioSystem &audio);

	/// Deleted copy constructor.
	Player(const Player &) = delete;

	/// Deleted copy-assignment constructor.
	Player &operator=(const Player &) = delete;

	/**
	 * Handles a command line.
	 * @param words A reference to the list of words in the command.
	 * @param id If present, the ID of the client requesting the
	 *   command, and, thus, the target of any unicast responses
	 *   this command generates.
	 * @return Whether the command succeeded.
	 */
	CommandResult RunCommand(const std::vector<std::string> &words,
	                         size_t id = 0);

	/**
	 * Sets the sink to which this Player shall send responses.
	 * This sink shall be the target for WelcomeClient, as well as
	 * any responses generated by RunCommand or Update.
	 * @param sink The response sink.
	 */
	void SetSink(ResponseSink &sink);

	/**
	 * Instructs the Player to perform a cycle of work.
	 * This includes decoding the next frame and responding to commands.
	 * @return Whether the player has more cycles of work to do.
	 */
	bool Update();

	/**
	 * Sends welcome/current status information to a new client.
	 * @param id The ID of the new client inside the IO system.
	 * @see DumpState
	 */
	void WelcomeClient(size_t id) const;

private:
	AudioSystem &audio;           ///< The system used for loading audio.
	std::unique_ptr<Audio> file;  ///< The currently loaded audio file.
	bool is_running;              ///< Whether the Player is running.
	const ResponseSink *sink;     ///< The sink for audio responses.
	std::uint64_t last_announced; ///< Time since last elasped message.

	/// The resource tree playd exposes.
	const static std::multimap<std::string, std::string> RESOURCES;

	//
	// Playback control
	//

	/**
	 * Tells the audio file to start or stop playing.
	 * @param playing True if playing; false otherwise.
	 * @see Play
	 * @see Stop
	 */
	CommandResult SetPlaying(bool playing);

	/**
	 * Ejects the current loaded song, if any.
	 * @return Whether the ejection succeeded.
	 */
	CommandResult Eject();

	/**
	 * Loads a track.
	 * @param path The absolute path to a track to load.
	 * @return Whether the load succeeded.
	 */
	CommandResult Load(const std::string &path);

	/// Handles ending a file (stopping and rewinding).
	void End();

	//
	// Seeking
	//

	/**
	 * Seeks to a given position in the current track.
	 * @param time_str A string containing a timestamp, followed by the
	 *   shorthand for the units of time in which the timestamp is measured
	 *   relative to the start of the track.  If the latter is omitted,
	 *   microseconds are assumed.
	 * @return Whether the seek succeeded.
	 */
	CommandResult Seek(const std::string &time_str);

	/**
	 * Parses time_str as a seek timestamp.
	 * @param time_str The time string to be parsed.
	 * @return The parsed time.
	 * @exception std::out_of_range
	 *   See http://www.cplusplus.com/reference/string/stoull/#exceptions
	 * @exception std::invalid_argument
	 *   See http://www.cplusplus.com/reference/string/stoull/#exceptions
	 * @exception SeekError
	 *   Raised if checks beyond those done by stoull fail.
	 */
	static std::uint64_t SeekParse(const std::string &time_str);

	/**
	 * Performs an actual seek.
	 * This does not do any EOF handling.
	 * @param pos The new position, in microseconds.
	 * @exception SeekError
	 *   Raised if the seek is out of range (usually EOF).
	 * @see Player::Seek
	 */
	void SeekRaw(std::uint64_t pos);

	//
	// Other
	//

	/**
	 * If the new time elapsed should be announced. Used to prevent
	 * spamming the connections with /player/time/elapsed messages.
	 * @return Whether time elapsed should be announced.
	 */
	bool ShouldAnnounceTime();

	/**
	 * Quits playd.
	 * @return Whether the quit succeeded.
	 */
	CommandResult Quit();

	/**
	 * Reads from and emits the requested resource.
	 *
	 * @param path The path of the response to emit, if possible.
	 * @param id The ID of the connection to which the Player should
	 *   route the response.  May be 0, for all (broadcast).
	 * @return The result of reading, which may be a failure if the
	 *   resource does not exist.
	 */
	virtual CommandResult Read(const std::string &tag, const std::string &path, size_t id) const;

	/**
	 * Writes to the requested resource.
	 *
	 * @param path The path of the resource to update, if possible.
	 * @param payload The intended new value of the reource.
	 * @return The result of writing, which may be a failure if the
	 *   resource does not exist, cannot be written to, or the payload
	 *   is invalid.
	 */
	virtual CommandResult Write(const std::string &path, const std::string &payload);

	/**
	 * Deletes the requested resource.
	 *
	 * @param path The path of the resource to update, if possible.
	 * @return The result of deleting, which may be a failure if the
	 *   resource does not exist, or the resource can't be deleted.
	 */
	virtual CommandResult Delete(const std::string &path);

	/**
	 * Resolves a failure to write or delete a resource.
	 * This checks to see if the resource is supposed to exist.  If it
	 * does, we return an 'invalid method'; if not, a 'not found'.
	 *
	 * @param path The path of the resource.
	 * @return The appropriate CommandResult for the failure.
	 */
	virtual CommandResult ResourceFailure(const std::string &path);
};

#endif // PLAYD_PLAYER_HPP
