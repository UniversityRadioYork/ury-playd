\hypertarget{audio__sink_8cpp_source}{\section{audio\+\_\+sink.\+cpp}
\label{audio__sink_8cpp_source}\index{src/audio/audio\+\_\+sink.\+cpp@{src/audio/audio\+\_\+sink.\+cpp}}
}

\begin{DoxyCode}
00001 \textcolor{comment}{// This file is part of playd.}
00002 \textcolor{comment}{// playd is licenced under the MIT license: see LICENSE.txt.}
00003 
00010 \textcolor{preprocessor}{#include <algorithm>}
00011 \textcolor{preprocessor}{#include <cassert>}
00012 \textcolor{preprocessor}{#include <climits>}
00013 \textcolor{preprocessor}{#include <cstring>}
00014 \textcolor{preprocessor}{#include <string>}
00015 
00016 \textcolor{preprocessor}{#include "portaudiocpp/PortAudioCpp.hxx"}
00017 
00018 \textcolor{preprocessor}{#include "../errors.hpp"}
00019 \textcolor{preprocessor}{#include "../sample\_formats.hpp"}
00020 \textcolor{preprocessor}{#include "../messages.h"}
00021 \textcolor{preprocessor}{#include "\hyperlink{audio__sink_8hpp}{audio\_sink.hpp}"}
00022 \textcolor{preprocessor}{#include "\hyperlink{ringbuffer_8hpp}{ringbuffer.hpp}"}
00023 
00024 \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} \hyperlink{classAudioSink_a152e5a388d4570211509a2a19a38c321}{AudioSink::RINGBUF\_POWER} = 16;
00025 
\hypertarget{audio__sink_8cpp_source_l00026}{}\hyperlink{classAudioSink_ab4adf46e3e93d35e2b5fb1ab0e75793b}{00026} \hyperlink{classAudioSink_ab4adf46e3e93d35e2b5fb1ab0e75793b}{AudioSink::AudioSink}(\textcolor{keyword}{const} \hyperlink{classAudioSink_ae5b8370aa17c24c6fc8f8e0c5778168c}{StreamConfigurator} c,
00027                      \hyperlink{classAudioSource_a1c8138ec9ffb9fd1394d0ad0782d60fa}{AudioSource::SampleByteCount} bytes\_per\_sample)
00028     : bytes\_per\_sample(bytes\_per\_sample),
00029       ring\_buf(RINGBUF\_POWER, bytes\_per\_sample),
00030       position\_sample\_count(0),
00031       just\_started(false),
00032       input\_ready(false)
00033 \{
00034     this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream} = decltype(this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream})(c(*\textcolor{keyword}{this}));
00035 \}
00036 
\hypertarget{audio__sink_8cpp_source_l00037}{}\hyperlink{classAudioSink_a18196e0dec3b4d58e17c454379ed0728}{00037} \textcolor{keywordtype}{void} \hyperlink{classAudioSink_a18196e0dec3b4d58e17c454379ed0728}{AudioSink::Start}()
00038 \{
00039     this->\hyperlink{classAudioSink_a00cbaaf2b4fcf5d9acb614b909234196}{just\_started} = \textcolor{keyword}{true};
00040     this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream}->start();
00041 \}
00042 
\hypertarget{audio__sink_8cpp_source_l00043}{}\hyperlink{classAudioSink_af1937ad09b555f0b88d285e8fd7cf433}{00043} \textcolor{keywordtype}{void} \hyperlink{classAudioSink_af1937ad09b555f0b88d285e8fd7cf433}{AudioSink::Stop}()
00044 \{
00045     \textcolor{keywordflow}{if} (!this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream}->isStopped()) \{
00046         this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream}->abort();
00047     \}
00048 \}
00049 
\hypertarget{audio__sink_8cpp_source_l00050}{}\hyperlink{classAudioSink_adfa8006db0d1cbe161f15232cb32a324}{00050} \textcolor{keywordtype}{bool} \hyperlink{classAudioSink_adfa8006db0d1cbe161f15232cb32a324}{AudioSink::IsStopped}()
00051 \{
00052     \textcolor{keywordflow}{return} !this->\hyperlink{classAudioSink_aac90e7d95e98ac08b7c661a301eff1b2}{stream}->isActive();
00053 \}
00054 
\hypertarget{audio__sink_8cpp_source_l00055}{}\hyperlink{classAudioSink_a9b3dbe861acd4bb7ac1903730a0a01f3}{00055} \textcolor{keywordtype}{bool} \hyperlink{classAudioSink_a9b3dbe861acd4bb7ac1903730a0a01f3}{AudioSink::InputReady}()
00056 \{
00057     \textcolor{keywordflow}{return} this->\hyperlink{classAudioSink_ad644a3477077e87f76cd24c9cb268f30}{input\_ready};
00058 \}
00059 
\hypertarget{audio__sink_8cpp_source_l00060}{}\hyperlink{classAudioSink_aaa92237f7ab548c1a898981f4dcd631c}{00060} \textcolor{keywordtype}{void} \hyperlink{classAudioSink_aaa92237f7ab548c1a898981f4dcd631c}{AudioSink::SetInputReady}(\textcolor{keywordtype}{bool} ready)
00061 \{
00062     this->\hyperlink{classAudioSink_ad644a3477077e87f76cd24c9cb268f30}{input\_ready} = ready;
00063 \}
00064 
\hypertarget{audio__sink_8cpp_source_l00065}{}\hyperlink{classAudioSink_aed168a8ce8ba39105431ab54ab08a007}{00065} \hyperlink{classAudioSink_ad2d7d33b3e937d057a4d72afad812737}{AudioSink::SamplePosition} \hyperlink{classAudioSink_aed168a8ce8ba39105431ab54ab08a007}{AudioSink::Position}()
00066 \{
00067     \textcolor{keywordflow}{return} this->\hyperlink{classAudioSink_ac3403a492b8aba8d483961d1ec09fa26}{position\_sample\_count};
00068 \}
00069 
\hypertarget{audio__sink_8cpp_source_l00070}{}\hyperlink{classAudioSink_a5ca539e3440d168eec0892114a947529}{00070} \textcolor{keywordtype}{void} \hyperlink{classAudioSink_a5ca539e3440d168eec0892114a947529}{AudioSink::SetPosition}(\hyperlink{classAudioSink_ad2d7d33b3e937d057a4d72afad812737}{AudioSink::SamplePosition} 
      samples)
00071 \{
00072     this->\hyperlink{classAudioSink_ac3403a492b8aba8d483961d1ec09fa26}{position\_sample\_count} = samples;
00073     this->\hyperlink{classAudioSink_a87184f85d6cfcc7310043b877caeaee2}{ring\_buf}.\hyperlink{classRingBuffer_a1eb1acca6905e7678fbbdb70238cdc26}{Flush}();
00074 \}
00075 
\hypertarget{audio__sink_8cpp_source_l00076}{}\hyperlink{classAudioSink_a455e211f4f16eaa21e7b75412cc8a8ae}{00076} \textcolor{keywordtype}{void} \hyperlink{classAudioSink_a455e211f4f16eaa21e7b75412cc8a8ae}{AudioSink::Transfer}(\hyperlink{classAudioSink_a60c1743d66e02b77f04791e72fa4cd0b}{AudioSink::TransferIterator} &start,
00077                          \textcolor{keyword}{const} \hyperlink{classAudioSink_a60c1743d66e02b77f04791e72fa4cd0b}{AudioSink::TransferIterator} &end)
00078 \{
00079     \textcolor{comment}{// No point transferring 0 bytes.}
00080     \textcolor{keywordflow}{if} (start == end) \{
00081         \textcolor{keywordflow}{return};
00082     \}
00083     assert(start < end);
00084 
00085     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} bytes = std::distance(start, end);
00086     \textcolor{comment}{// There should be a whole number of samples being transferred.}
00087     assert(bytes % \hyperlink{classAudioSink_a5eab0f7111187c0416feb542010e4a2e}{bytes\_per\_sample} == 0);
00088     assert(0 < bytes);
00089 
00090     \textcolor{keyword}{auto} samples = bytes / this->\hyperlink{classAudioSink_a5eab0f7111187c0416feb542010e4a2e}{bytes\_per\_sample};
00091 
00092     \textcolor{comment}{// Only transfer as many samples as the ring buffer can take.}
00093     \textcolor{comment}{// Don't bother trying to write 0 samples!}
00094     \textcolor{keyword}{auto} count = std::min(samples, this->\hyperlink{classAudioSink_a87184f85d6cfcc7310043b877caeaee2}{ring\_buf}.\hyperlink{classRingBuffer_ab00617ab6e379ad146cb7b80079f4c4c}{WriteCapacity}());
00095     \textcolor{keywordflow}{if} (count == 0) \{
00096         \textcolor{keywordflow}{return};
00097     \}
00098     assert(0 < count);
00099 
00100     \textcolor{keyword}{auto} start\_ptr = \textcolor{keyword}{reinterpret\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(&*start);
00101     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} written\_count = this->\hyperlink{classAudioSink_a87184f85d6cfcc7310043b877caeaee2}{ring\_buf}.\hyperlink{classRingBuffer_aa7f863968cb641946b0cf341bda11e16}{Write}(start\_ptr, count);
00102     \textcolor{comment}{// Since we never write more than the ring buffer can take, the written}
00103     \textcolor{comment}{// count should equal the requested written count.}
00104     assert(written\_count == count);
00105 
00106     start += (written\_count * this->\hyperlink{classAudioSink_a5eab0f7111187c0416feb542010e4a2e}{bytes\_per\_sample});
00107     assert(start <= end);
00108 \}
00109 
\hypertarget{audio__sink_8cpp_source_l00110}{}\hyperlink{classAudioSink_ad3534ea4210aa83b42706c0361fd3e8d}{00110} \textcolor{keywordtype}{int} \hyperlink{classAudioSink_ad3534ea4210aa83b42706c0361fd3e8d}{AudioSink::paCallbackFun}(\textcolor{keyword}{const} \textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *out,
00111                              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} frames\_per\_buf,
00112                              \textcolor{keyword}{const} PaStreamCallbackTimeInfo *,
00113                              PaStreamCallbackFlags)
00114 \{
00115     \textcolor{keywordtype}{char} *cout = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(out);
00116 
00117     std::pair<PaStreamCallbackResult, unsigned long> result =
00118                     std::make\_pair(paContinue, 0);
00119 
00120     \textcolor{keywordflow}{while} (result.first == paContinue && result.second < frames\_per\_buf) \{
00121         result = \hyperlink{classAudioSink_a450ad1c0c64ddcc9b9a40d325983cbd9}{PlayCallbackStep}(cout, frames\_per\_buf, result);
00122     \}
00123     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(result.first);
00124 \}
00125 
\hypertarget{audio__sink_8cpp_source_l00126}{}\hyperlink{classAudioSink_a450ad1c0c64ddcc9b9a40d325983cbd9}{00126} \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} \hyperlink{classAudioSink_a450ad1c0c64ddcc9b9a40d325983cbd9}{AudioSink::PlayCallbackStep}(\textcolor{keywordtype}{char} *
      out,
00127                                                    \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} frames\_per\_buf,
00128                                                    \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} in)
00129 \{
00130     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} avail = this->\hyperlink{classAudioSink_a87184f85d6cfcc7310043b877caeaee2}{ring\_buf}.\hyperlink{classRingBuffer_a7086cc66306105db205842af7a88c2d8}{ReadCapacity}();
00131     \textcolor{keywordtype}{bool} empty = avail == 0;
00132 
00133     \textcolor{comment}{/* If we've just started this stream, we don't want to hand PortAudio}
00134 \textcolor{comment}{       an incomplete frameâ€”we'd rather wait until we have enough in the}
00135 \textcolor{comment}{       ring buffer before starting to play out. */}
00136     \textcolor{keywordtype}{bool} wait = this->\hyperlink{classAudioSink_a00cbaaf2b4fcf5d9acb614b909234196}{just\_started} && (avail < frames\_per\_buf);
00137 
00138     \textcolor{keywordtype}{bool} failed = wait || empty;
00139     \textcolor{keyword}{auto} fn = failed ? &\hyperlink{classAudioSink_a6e1b9254b242231ba8168e5e27d602ff}{AudioSink::PlayCallbackFailure}
00140                      : &\hyperlink{classAudioSink_a2194fd0629b52c550c9eb326f8ae10cc}{AudioSink::PlayCallbackSuccess};
00141     \textcolor{keywordflow}{return} (this->*fn)(out, avail, frames\_per\_buf, in);
00142 \}
00143 
\hypertarget{audio__sink_8cpp_source_l00144}{}\hyperlink{classAudioSink_a2194fd0629b52c550c9eb326f8ae10cc}{00144} \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} \hyperlink{classAudioSink_a2194fd0629b52c550c9eb326f8ae10cc}{AudioSink::PlayCallbackSuccess}(
00145                 \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} avail, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} frames\_per\_buf,
00146                 \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} in)
00147 \{
00148     this->\hyperlink{classAudioSink_a00cbaaf2b4fcf5d9acb614b909234196}{just\_started} = \textcolor{keyword}{false};
00149 
00150     \textcolor{keyword}{auto} samples\_pa\_wants = frames\_per\_buf - in.second;
00151     \textcolor{keyword}{auto} samples\_read = \hyperlink{classAudioSink_a00ed918435d6f65b9533869453d5ae56}{ReadSamplesToOutput}(out, avail, samples\_pa\_wants);
00152 
00153     \textcolor{keywordflow}{return} std::make\_pair(paContinue, in.second + samples\_read);
00154 \}
00155 
\hypertarget{audio__sink_8cpp_source_l00156}{}\hyperlink{classAudioSink_a6e1b9254b242231ba8168e5e27d602ff}{00156} \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} \hyperlink{classAudioSink_a6e1b9254b242231ba8168e5e27d602ff}{AudioSink::PlayCallbackFailure}(
00157                 \textcolor{keywordtype}{char} *out, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} frames\_per\_buf,
00158                 \hyperlink{classAudioSink_a73002cc57611ac384c4e9d419e706e50}{PlayCallbackStepResult} in)
00159 \{
00160     decltype(in) result;
00161 
00162     \textcolor{keywordflow}{if} (\hyperlink{classAudioSink_a9b3dbe861acd4bb7ac1903730a0a01f3}{InputReady}()) \{
00163         \textcolor{comment}{// There's been some sort of genuine issue.}
00164         \textcolor{comment}{// Make up some silence to plug the gap.}
00165         \hyperlink{classDebug}{Debug}() << \textcolor{stringliteral}{"Buffer underflow"} << std::endl;
00166         memset(out, 0, this->\hyperlink{classAudioSink_a5eab0f7111187c0416feb542010e4a2e}{bytes\_per\_sample} * frames\_per\_buf);
00167         result = std::make\_pair(paContinue, frames\_per\_buf);
00168     \} \textcolor{keywordflow}{else} \{
00169         \textcolor{comment}{// End of input is ok, it means the stream can finish.}
00170         result = std::make\_pair(paComplete, in.second);
00171     \}
00172 
00173     \textcolor{keywordflow}{return} result;
00174 \}
00175 
\hypertarget{audio__sink_8cpp_source_l00176}{}\hyperlink{classAudioSink_a00ed918435d6f65b9533869453d5ae56}{00176} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \hyperlink{classAudioSink_a00ed918435d6f65b9533869453d5ae56}{AudioSink::ReadSamplesToOutput}(\textcolor{keywordtype}{char} *&output,
00177                                              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} output\_capacity,
00178                                              \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} buffered\_count)
00179 \{
00180     \textcolor{comment}{// Transfer the maximum that we can offer to PortAudio without}
00181     \textcolor{comment}{// overshooting}
00182     \textcolor{comment}{// its sample request limit.}
00183     \textcolor{keywordtype}{long} transfer\_sample\_count = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{long}\textcolor{keyword}{>}(
00184                     std::min(\{ output\_capacity, buffered\_count,
00185                            \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(LONG\_MAX) \}));
00186     output += this->\hyperlink{classAudioSink_a87184f85d6cfcc7310043b877caeaee2}{ring\_buf}.\hyperlink{classRingBuffer_af892330ee102bd50a493b8afa814a0f0}{Read}(output, transfer\_sample\_count);
00187 
00188     \textcolor{comment}{// Update the position count so it reflects the last position that was}
00189     \textcolor{comment}{// sent}
00190     \textcolor{comment}{// for playback (*not* the last position decoded).}
00191     this->\hyperlink{classAudioSink_ac3403a492b8aba8d483961d1ec09fa26}{position\_sample\_count} += transfer\_sample\_count;
00192     \textcolor{keywordflow}{return} transfer\_sample\_count;
00193 \}
\end{DoxyCode}
